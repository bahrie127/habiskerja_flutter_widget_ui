 So back in our main.dart file, we have that main function. As you know, this is a function, it returns nothing, takes no arguments and right now, we also have nothing in the function body. Now as you learned, main is a function which automatically is executed when the app starts by Flutter and Dart because it's in the main.dart file which you therefore also shouldn't rename. Now in here, we need to add some code that actually brings something onto the screen. For that, it's important to understand that on the screen, we basically see a bunch of widgets. Flutter is about widgets, it's so important to understand this. Every Flutter app you're building is just a bunch of widgets and widgets are the UI building blocks you see on the screen, things like the app bar, maybe some image, maybe a list with list items and as you can see here for example, widgets also often contain other widgets, like that list which has list items. So you compose your Flutter app as that tree of widgets which I already mentioned before, which has a root widget which is your entire app and in there, you have your other widgets which yet might hold other widgets thereafter, even your entire page, so the entire thing that holds all the widgets on your page on your screen is a widget in Flutter. So since everything in Flutter is a widget and since the entire app is a widget, we probably need to create such an app widget which then has other widgets to see something on the screen and that's 100% correct. Now to create such a widget, we need to create a class because a widget is a special type of object so to say and you learned that you need classes to create objects. So let's add a class here and you can give it any name you want and I will name it MyApp, following that naming convention which is called pascal case, where you have a capital starting character and then every word inside the word also starts with a capital starting character, no blanks in between, no underscores, no dashes, your classes should be named like this. The concrete name if this is MyApp, MyCoolApp or something else is totally up to you. Now this would be a class but as you probably can imagine, a widget that really can be seen on the screen is not that trivial to create because in the end, the pixels on the screen do need to be controlled. Now thankfully, we don't have to write that logic on our own, Flutter does all of that behind the scenes and therefore, our class here now uses a feature called inheritance. 
 That means that it builds up on a base class, gets all the features of that base class and only adds new features to it. We do inherit by adding the extends keyword here after the class name before the curly braces and that inform Dart that this class will be based on some other class and you can only extend one class at a time. Now the class I do want to extend here is not a class we will write but a class provided by Flutter. Now of course in our whole project here, we only have one Dart file in the lib folder and that's our own Dart file but please remember that we have that pubspec file where we define which dependencies our application has or our Dart project has and here we have one dependency and that's Flutter, the Flutter framework. Now the files of that framework are not stored here in that project, instead they're stored somewhere else on your machine, typically in your user folder somewhere but you can import from these files because the connection is established with the help of this entry in the pubspec.yaml file. So now in the main.dart file, we can inform Dart that we want to reach out to some other file, in this case from the Flutter framework, that gives us the class which we would want to extend here. We do that by adding the import keyword, this tells Dart Hey I want some functionality which is not in this file but which is in some other file. Now you can point at your own files there too and we'll do that later but you can also point at third-party packages which are part of your project. You do this by adding package: and then the name of the package, which in this case is Flutter and then a lot of packages have a lot of files that make up this package. So you can add a slash here and then point at a concrete file, in this case this would be material.dart. That's one of the files the Flutter framework exposes to you, it has a lot of built-in widgets following the material theming and later, you will also learn how to make your apps look good on iOS but material themes also work on iOS and besides these prestyled material looking widgets, the material.dart file also has a base class which allows you to create your own widgets and that's the stateless widget class. So we extend stateless widget here and this now turns our class into a class which can be used as a widget by Flutter. However, now we've got a new error here that it's missing a correct implementation of StatelessWidget.build. 
 Now what does this mean? Now .build signals that this seems to be some property, so a variable, which is part of that class or maybe it's a function that's part of the class. We haven't had a look at this before but besides variables, you can also have functions inside classes. Now variables inside of classes would be called properties, functions inside of classes are called methods. So we have to add a special method here, now how do I know that it's a method and not a property? It's just something you have to memorize, one of the very few things you have to memorize. So here, this is a method which is missing, so let's add build here since it's a method and therefore effectively a function, we can add parentheses here and we have to add them in curly braces to mark the body of that function. Now functions can take arguments and if we hover over this to read the error here, we actually see that it isn't a valid override, whatever that means, of the build method and indeed, it should take a build context as an argument. So let's add an argument here, you can name it ctx or context, whatever you want, it's a special type of object, a special object which will be passed into the build method automatically because you will never call that method, Flutter will call it whenver it needs to draw something onto the screen and context is an object into which I'll dive deeper later, in the end it holds some meta information about our app and about this widget we're building but for now let's just add it and let's also add a type annotation. The type is build context which is the end class that is also defined material.dart which is why we can use it here. So build context is a special object type provided by Flutter in the material.dart file and this context object is of that type and we get it automatically by Flutter. Now build is also a function or a method which returns something, it needs to return a widget because you work with the widgets in Flutter, your entire app as a widget, we're trying to build an app here, the build function is what Dart and Flutter will call in the end when they try to draw something onto the screen and therefore, the build method here needs to return a widget. Now just like build context, widget is in the end a class and every class automatically then also is a type, which is provided by material.dart. 
 Now we need to return such a widget here inside of MyApp and there, there is a special widget which we should return and that's the MaterialApp widget, also provided by material.dart, that's a widget provided by the Flutter team which does some base setup to turn your combination of widgets into a real app that can be rendered, it does a lot of heavy lifting behind the scenes you could say. MaterialApp also takes a couple of arguments, as you can see it's a pretty long list and all these arguments are so-called named arguments. Now thus far, we only saw something which are positional arguments, which means the build method takes an argument, context, because it takes one argument we accept it like this by giving it a name in the end and the first and only argument which will be passed into build when Flutter calls the build method will be passed into context or will be available as context. In our example here, we had two positional arguments in addNumbers, num1 and num2 and what we passed in as a first argument here when we call the function would end up in num1, what we passed in as the second argument here would end up in num2. Now MaterialApp uses so-called named arguments which means we don't pass in data in order here but because that has a lot of possible arguments we can set, which are all optional in the end, we target an argument by its name and there for the moment we only need the home argument. Home is basically the core widget which Flutter will bring onto the screen when this entire app is mounted to the screen and here we could use a text widget which is yet another widget built into Flutter and you will work a lot with these built-in widgets because thankfully, you rarely have to reinvent the wheel and all the core UI building blocks you need in modern apps already exist. Text takes a string, you learned about that data type which you can create with single or double quotes as an input and here we could print Hello. So now we have that MaterialApp widget which is provided by material.dart with that named argument, which in case it's not entirely clear is something we'll also use throughout this course and we'll also create our own functions that take named arguments so that this becomes clearer and then here, we also have hello which we passed to text. Now as a side note if you're wondering whether MaterialApp is a function or a class, it is a class and yet we can pass data to it with a feature called a constructor but that's also something I'll come back to later. For now, let's just accept that this is some code which will create something which can be treated as an app because MaterialApp does a lot of heavy lifting behind the scenes and which should also output some code. Now we just need to wire up that main function with this class here.


 To wire these two things up and see something on the screen, in main, we need to execute some code which takes our widget here and draws it to the screen and for that, there is another function provided by material.dart and that is called runApp. Now runApp is a normal function but not written by us but written by the Flutter team and exposed in that material.dart file. So as you can probably tell, importing that material.dart file unlocks a lot of core features which we need to build an app. Now runApp does what the name suggests, so it basically runs our Flutter app once the Android app booted up or the iOS app, whatever it is and that simply means it now tries to take our widget tree and draw something onto the screen that's based on that tree, so here it would draw that text here onto the screen. For that however, we need to tell runApp what our core widget is and that's our MyApp widget of course. So here we pass MyApp and we execute this like a function by adding parentheses, that is important, don't forget these parentheses, otherwise you would use it as a type but this does not need a type but a concrete object and you instantiate an object based on a class by adding parentheses. That's also what we did here when we created our persons, right. Now runApp does just that, it runs the app, takes our widgets and runs that, to be precise what it does with our widget is of course it creates that, we're calling the constructor after all, so such a widget object is getting created and then runApp does take this object which we passed to it in the end here, which we pass as an argument to runApp, we pass the finished object, the finished widget object here after all by calling the constructor. runApp takes that and calls the build method for us, that's in the end what it does and that's how build gets triggered here for the first time and how this construction of our app then continues and how something gets rendered onto the screen and therefore if we now save that file and we go to debug and again start this without debugging, we should now be able to bring this back onto the emulator and see a very basic and ugly application there, which somewhere outputs hello. And as you can also tell therefore is that we basically only care about the user interface and what we see there and that's a cool thing. 
 We don't have to care about rendering individual pixels or managing the lifecycle of the app, starting it up and listening to events on the home screen of our Android device, we do none of that, what we do here is we control what ends up on the screen. So now this is getting built into an apk here for my Android emulator, once it's done, it launches up and we see this. Now this is the expected result, we haven't defined any styling, we haven't defined anything that will lead to something more beautiful being rendered but we see hello here. And that therefore proves that this basic code works, that we created our own widget class which is a normal class with some extra features provided by stateless widget and that this was accepted by the main function to run our app with the help of runApp.


 To get a more beautiful app, it would be a good start to have a white background and maybe not this reddish text with the double yellow underline and we only get this here because I'm outputting the text widget in the MaterialApp and that is enough to bring something onto the screen but it has no default stylings for our mobile app. It does not have any background or any appBar because for Flutter, you have to configure that all manually. Keep in mind that Flutter controls the entire UI, all the pixels on the screen are controlled by your Flutter app in the end, by the Flutter framework. It does not take an existing mobile app and just mix in some widgets or some components, it controls the entire app instead and therefore you also have to give clear instructions about every detail, what should be the background color, should there be an appBar? And to do that, there is a little helper widget which you can use and I'll replace my text widget here with it and that's scaffold. Now scaffold is yet another widget which is baked into material.dart. It's made available there and scaffold has the job of creating a base page design for your app, so it will give you a basic design and structure and color scheme or coloring for giving you a UI that looks more like a regular mobile app page. Scaffold also has a couple of named arguments and you can always hit control space to get some auto completion in the IDE and get a list of the named arguments that are supported and here you can also cycle through with the arrow keys to get some help and some explanation of what each of these named arguments does and there are tons of arguments and typically, you only use a few of them for each widget you are creating and here for example we could add an appBar and then a body, body is basically the main content of the page and appBar as the name suggests is the bar at the top. So here, we can add appBar and now again appBar if we hover over that takes a preferred size widget. Now what's a preferred size widget? Well, it's a special kind of widget you could say, you could build it on your own but since the appBar is such a typical and specific thing in any application, you can simply pass in a pre-built widget which is also named appBar. appBar again is a widget provided by material.dart and as always, all widgets are classes, so here we are instantiating a class but this is a class which extends stateless or a stateful widget in the end and appBar then again take some configuration. 
 So here if I hit control space while being within the parentheses with my cursor, I get some explanation on what I can pass here and you can pass a bunch here. You can pass actions which would be buttons in your appBar, you can pass some of the bottom tabs if you want to add some tabs in there. You can change the background color but for now, I only want to set my title, title is a named argument that allows me to set a title for this page and here we could add my first app as a title. However title does not take some text but if we have a look at it, title actually takes a widget and can always hover over that to see what goes in there. So it takes a widget, not some text but it takes the text widget and now this could be confusing but the text widget is not some plain text but this is actually a widget which takes some plain text, which takes a string therefore as a positional first argument and then it outputs some text on the screen, the text we're passing in here but text is a widget, not the plain text. This here with the quotes, that is plain text. So now I'm passing in my text widget, which in turn takes that plain text as a widget for the title argument in my appBar widget and we already see a bunch of widgets here and whilst this can be confusing initially, this is how Flutter works, you compose your user interface by mixing multiple widgets together. So here we have our overall app widget, which then uses a scaffold widget to get some basic page styling, which then has an appBar widget for its appBar which then takes a text widget. Now of course, we might not just want an appBar here but also a body, so we can add body here. Now that's on the scaffold widget, so make sure you are adding this on the right level, outside of the appBar and outside of the text widget arguments but on the scaffold arguments, here we can add body and the body here again could be our text, like this is my default text. Now one recommendation I have here, always add a comma after closing parentheses because this will allow you to autoformat this in a very readable way and that's just a feature the Flutter extension for Visual Studio Code and also for Android Studio offers. You can format your document with a certain key binding and you can find that if you go to keyboard shortcuts and there, you search for format document in Visual Studio Code, then you should find a key binding which you can also change if you're not happy with the default and with that key binding if you press that, you auto format your code to be a bit more readable and with these trailing commas at the end of every line, Flutter is able to format this nicer. 
 If I would remove this comma after my body argument here, you'll see now it formats this a bit more unstructured and for short snippets like this, this is fine but the longer your widget trees get, the easier and nicer it is to read this with these trailing commas which improve the auto formatting but that's just a tiny hint for writing clean code. So with that, we finished our scaffold widget which we didn't create ourselves but which is provided by Flutter and we passed an appBar and a body. And now if we save this, it should automatically rebuild and hot reload your application. Hot reload means that it didn't need to restart the app, which means it keeps the current state, if we change any data in there, it wouldn't restart and override that, instead it keeps the app as it was and just injects our new code into it, which is some magic managed by Flutter during development and therefore if we go back, now this looks way better. Instead of that ugly hello which was red with a black default, with a black background, we now have our nicer page look here with an appBar, with a little drop shadow, with a blue background, with our title that automatically has a color that contrasts against the background and then here we have this is my default text which we output in the body, so in the main area of this page. And this is how we build Flutter apps, how we work with these widget trees and how we can also structure our app here in code and that is what I meant when I mentioned in the first section that with Flutter and Dart, we build mobile apps by building the user interface in code. We're not using a drag and drop editor here, instead we're writing some code which defines what should end up on the screen. And now we have these basic set, let's take the next step towards our first, a little bit more realistic course application.

 In this first, a little bit more realistic application, I want to build a very simple personality quiz application where you answer a couple of questions and based on the choices you made, we charge your personality. For that, we'll use that current application we have here, this very lean application where we right now only output the default text and we'll build up on that to present a question and some buttons that allow the user to choose an answer. Now for that, we certainly need a text widget to output the question and below that, I want to have a couple of buttons that allow the user to choose different answers and now here's a problem. We have body and body is the place where we add the widget that should be shown in all that white area and body only takes one widget, I can't add a second widget here, I can't add another text, second text. You already see I get an error here because now this would actually not be passed as an additional value to body But Dart would try to pass this as a positional argument passed to scaffold which doesn't take any positional arguments here. So that does not work and we also can't concatenate this by adding a plus here, all of that doesn't work. We can really only pass one widget here to body so what can we do? I want to pass more than one widget, I want to have a text and a couple of buttons. For this, it's important to understand that we have different types of widgets in Flutter. We have the visible widgets which are related to user input and to outputting data, things like a button or a text or a card and we have only seen the text from all these examples here thus far but there are more widgets like the RaisedButton which renders a button and other widgets and we'll see all of those throughout the course. Now these are the widgets which we see, we see a button, we see the text right, that is what we see and that is of course crucial for any application but equally crucial are invisible widgets that help us with layout and with controlling how our widget tree behaves and how it looks like and there we got things like row, column, ListView and so on. These are also widgets that ship with Flutter which we don't have to build ourselves, which we don't see themselves but which help us with structuring our content. 
 So these widgets give our app structure and control how visible widgets are drawn onto the screen and therefore of course, they're super important. There also is a very important widget which also ships with Flutter, the container widget which kind of belongs into both categories as you will learn once we use it because it by default is invisible but you can also give it some styling so that you can see it but before we focus on that, let's actually take row, column and so on to work on our quiz app and add both a question and a couple of answer buttons.


 What's this state thing I mentioned? In general, state is data or information your app or your widgets in your app use. State can be things like a username or in our case, the index of the question we want to show. So app wide state would be things like is the user authenticated or if we're building an app that users can use to find new jobs, we could have the overall jobs we loaded from a server. widget state could be things like the current user input or are we currently loading data and do we want to show a spinner or as in our application, the widget state of the app widget we have could be which question is currently selected and that state can and typically will change in an application. However as the name suggests since we're extending a stateless widget here, this widget can't have state. Now that might sound very restrictive and strange, since we typically have interactive applications where things should change, why would we have widgets that can't change? Typically in your Flutter application, you will have more than one widget and we'll soon have more than one which is here as well and some widgets are only there to output something, like that text widget which is built into Flutter. This is a widget which has no state in it, it gets the text from outside passed in, that is passed in when the widget is created so it never changes whilst the widget is there and it just outputs the text, it does nothing else, it doesn't react to clicks on the text or anything like that. Therefore, text would be a perfect stateless widget and indeed it is and a lot of the widgets are only concerned with outputting data with certain styles, certain colors or in a certain structure. Some widgets however need to change data, like our app here, we want to change that question index and for this, we can convert that stateless widget into a so-called stateful widget. The difference between stateless and stateful widgets is that in a stateless widget, we have our widget and the build method which is used to render the UI. 
 Now we can pass in data from outside into the stateless widget through the constructor of that class, so of the widget class, we'll do this later too. And this data can change and actually Flutter would rebuild that widget when that external data changes but inside of the widget class, the data will never change, we can only receive new data from outside and that will basically rebuild the widget. Now a stateful widget also has a build method that builds a widget and that renders a UI therefore but here, we can also get our input data, so data passed in through the constructor of the widget class but we also can have some internal state and that's the core thing here and this widget will get re-rendered, so the user interface will get updated by Flutter whenever either that external, that input data changed or when our internal state changed and that's the core difference. Here we really just have a MyApp widget which doesn't take any input data, so it doesn't even take that but it certainly can't have internal data, internal state because it's a stateless widget. Now how can we turn this into a stateful widget now? For turning this into a stateful widget, you could think that you simply rename this into stateful widget but now we have an error because it's not that simple. You also can refactor this in Visual Studio Code and Android Studio if you have the Flutter extensions installed which you should have. Then you can check your key bindings and search for refactor and you should find a key binding which you can use to get refactoring suggestions and if you place your cursor on stateless widgets, if you click on that and you then use that key binding, here I get the suggestion of converting this to a stateful widget. We could do that and in the future, we will take advantage of this because it's super fast but here I won't do that because I want to show you what makes up a stateful widget step-by-step. Now the first step is indeed that you rename this to stateful widget, stateful widget is a widget, is a class provided by the material package here, so this exists so you can use that. 
 Now however, a stateful widget is a bit more complex than a stateless widget. It's actually not just one class, it's instead a combination of two classes. So let's close the curly brace of our first class here and let's add a second class with all of that content down there, with the build method and so on being part of that second class. This is now typically named MyAppState, not my app state but your widget name plus state after it, so in this case MyAppState because my widget here is also named MyApp. MyAppState now extends state and now you can open your curly brace again. State again is a class imported from material.dart and state is a generic class. Now comes the more complex part, why do we have two classes first of all? Because the way Flutter works internally, into which I'll dive a bit deeper later, is that the widget itself can be recreated, this class can be recreated, when the external data changes, this will be recreated basically. The state however is persistent, it's attached to that widget, so it's attached to that element in the user interface which you see but unlike that class here, it's technically not recreated and that's important for storing your state so that when you question index changes and the external data passed into the widget itself changes, only that is rewritten, is rebuilt and our data here is not reset and if that's not entirely clear yet, it will become clear once we start passing data into the widget itself. So we have that separation so that this data here, the state can be persistent whilst this widget itself can be rebuilt. Now we need to tell Flutter that this state class belongs to this widget class however, to us humans, to us developers, it's clear because of the naming, MyAppState and MyApp but the naming is just a convention, it's not a rule and therefore, Flutter does not take the name as an indicator that this class here belongs to this widget. Instead to set up a connection, we need two things. First of all, state is a generic type so we should add angled brackets there and in between, we add a pointer at our class here, so here I add MyApp. 
 This tells Dart and Flutter that this state belongs to the MyApp class, so this is one part of the connection. The second part has to be done here inside of MyApp class, so inside of the widget. There, we have to add a new method, the createState method. Now here, I get a suggestion by my IDE and if I hit enter, it automatically adds it for me. Now createState as you can see is a method that takes no arguments but that in the end has to return a state object which is connected to a stateful widget. Now that's exactly what we have down there, it's an object that's of type state in the end because it inherits from state and that is connected to MyApp which is a stateful widget. So here, we want to return a new MyAppState object. Here we create a new object based on that class, which also knows about this class and therefore we now connected the two pieces, the two classes from both ends. Here we also have override again because createState is a method provided by stateful widget, it needs to be overriden and again to be clear that we are doing this deliberately, we add @Override here. Now we have the connection set up from both sides and now with this change, the build method is now inside the state, not inside the widget because the state holds the data that is used by the build method. With this now changed and nothing else changed, if we now save this and we restart our application because if you do such a transformation, hot reload typically doesn't work so you need to do a full restart with that green arrow here or the shortcut which you chose there. Now with that, if you go back and you click Answer 1, please watch the what's your favorite color text, still nothing changes. We see the output go up there with the print statement which is still part of answer question but still nothing changes in the UI. Well the reason for that is that still, even with this transformation to stateful widget and state, Flutter doesn't automatically update and re-render the user interface just because we tap the button and that's good because for performance, it would not be that great if Flutter would re-render the user interface on every tap of the user. 
 If we tap somewhere and Flutter takes this as an indicator to re-render everything, then our app would certainly have a horrible performance. Instead we have to tell Flutter that we're about to change the state and that when this state is changed, it should re-render this widget. We do that by wrapping the code where we do change data inside of our state, that is reflected in the user interface and the question index is of course reflected because it controls which question is shown. So when we change that, we wrap this in a set state function. Set state is a function or a method to be precise that is provided by that state class which we inherit and set state takes a function, typically an anonymous function, so a function here with no arguments and then a function body and inside of this function which we passed to the set state function, so a function that takes a function as an argument, that's just how it is, inside of this function, we move that code or we change our property in this case, the property which also is used in build. Now with that if we now save this and we do a full restart, if you now watch what's your favorite color and I click Answer 1, you see now it changes to what's your favorite animal and this now happens because of set state and us using a stateful widget. Now throughout this course, we'll work with both, stateless and stateful widgets. As you learned, the majority of widgets will actually be stateless because more often than not, you're just concerned with outputting something in a nice way but occasionally, you need to change data, you need to react to user input and change something and then we'll use stateful widgets which are the other core type of widget Flutter supports and knows. By the way, please note that if you press this more than once, you of course get an error because then you change question index to two and you would try to access the third question which we of course don't have.

